[TOC]



#### JDK基础模块

参考源码分析：[jdk1.8-source](https://github.com/zcswl7961/jdk1.8-source)

- [x] ReentrantLock   [逐行源码分析AbstractQueuedSynchronizer(AQS)中ReentrantLock的源码实现](http://www.zcswl7961.com/index.php/2020/12/03/abstractqueuedsynchronizer/)
- [x] CountDownLatch [逐行源码分析AbstractQueuedSynchronizer(AQS)中CountDownLatch的源码实现](http://www.zcswl7961.com/index.php/2020/12/09/aqs-countdownlatch/)
- [x] Semaphore [逐行源码分析AbstractQueuedSynchronizer(AQS)中Semaphore的源码实现](http://www.zcswl7961.com/index.php/2020/12/09/aqs-semaphore/)
- [x] HashMap [Java包-HashMap](https://www.processon.com/view/link/60139ed4079129652cdf9c93)
- [x] TreeMap [Java包-TreeMap](https://www.processon.com/view/link/60139ed4079129652cdf9c93)
- [x] LinkedHashMap [Java包-LinkedHashMap](https://www.processon.com/view/link/60139ed4079129652cdf9c93)
- [x] ConcurrentHashMap [Java包-ConcurrentHashMap](https://www.processon.com/view/link/60139ed4079129652cdf9c93)
- [x] Executor [线程池](https://www.processon.com/view/link/60139f617d9c08426cf87106)
- [x] ThreadPoolExecutor [线程池-ThreadPoolExecutor](https://www.processon.com/view/link/60139f617d9c08426cf87106)
- [x] ScheduledThreadPoolExecutor [线程池-ScheduledThreadPoolExecutor](https://www.processon.com/view/link/60139f617d9c08426cf87106)
- [x] ArrayList [Java包-ArrayList](https://www.processon.com/view/link/60139f617d9c08426cf87106)
- [x] LinkedArrayList [Java包-LinkedList](https://www.processon.com/view/link/60139f617d9c08426cf87106)
- [x] Queue [Java包-Queue和Deque](https://www.processon.com/view/link/60139ed4079129652cdf9c93)
- [x] ClassLoader#getResource Class#getResource [Class和ClassLoader关于getResource()，getResourceAsStream()的区别](https://blog.csdn.net/zcswl7961/article/details/103831231)
- [x] Throwable [Java包-Throwable体系](https://www.processon.com/view/link/60139ed4079129652cdf9c93)
- [x] ServiceLoader SPI [Java包-ServiceLoader](https://www.processon.com/view/link/60139ed4079129652cdf9c93)
- [x] Reference 引用类型 [Java包-Reference](https://www.processon.com/view/link/60139ed4079129652cdf9c93)
- [x] ThreadLocal [ThreadLocal的内存泄漏问题](https://www.zcswl7961.com/index.php/2021/02/03/threadlocal/) [一个面试进行的ThreadLocal源码深入分析](https://blog.csdn.net/zcswl7961/article/details/100769425?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161249075716780261973706%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=161249075716780261973706&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v1~rank_blog_v1-1-100769425.pc_v1_rank_blog_v1&utm_term=ThreadLocal&spm=1018.2226.3001.4450)
- [x] Thread [线程](https://www.processon.com/view/link/60139f617d9c08426cf87106)



##### **LinkedHashMap**

​	1，LinkedHashMap是基于HashMap的基础上进行实现

​	2，插入的字段封装成了自己设置的Entry，并且加了一个before 和after，表示当前数据链接的前一个值和后一个值（双端链表）

​	插入的时候都是插入到链表的尾部：

​	**LinkedHashMap构造函数有一个参数：accessOrder：默认的情况下时false：表示LinkedHashMap是按照对应的插入顺序 true：表示访问顺序，如果一个值被访问了之后，会插入到链表的最后面，链表最前面的值表示都是最近未访问的值**

​	使用LinkedHashMap可以作为LRU缓存淘汰算法工具：

```
/**
 * LRU 最近最少使用的操作
 * LinkedHashMap 双端链表的方式
 * @author zhoucg
 * @date 2021-04-07 16:17
 */
public class LRU extends LinkedHashMap<Integer, Integer> {
    private int capacity;

    public LRU(int capacity) {
        super(capacity, 0.75f, true);
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key,value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity;
    }
}
```

##### HashMap

HashMap的内部的数据结构：数组+链表（链表长度大于8的时候会红黑树）

HashMap源码分析是一个很值得分析的点，

###### 1，为什么HashMap的长度是2的n次幂

​	核心得原因就是：**保持hashcode的散列，同时防止hash冲突**  

[博客原理](https://www.cnblogs.com/zxporz/p/11204233.html)

这是一个很好得问题，需要去了解出HashMap取位置的算法操作，以及其内部的核心算法：  
**HashMap根据指定的key取hash值得操作：**  

```
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
```

**HashMap取对应数组槽得算法：**  
```
tab[i = (n - 1) & hash])
```

**HashMap是如何将对应得key存入到指定得数组中（找槽位）**

首先HashMap会根据传入得key值，重新计算出新得hashcode值，计算方法为：  
```
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
```
即：**如果传入得key为null，返回得hashCode为0**【这个是特殊情况】  
1，首先会将k得原始得hashcode值无符号得右移16位，即返回的hashcode值（int） 低16位存储的是原hash值得高16位  
2，然后在和原来的hashcode进行亦或操作。【亦或操作即相同取0， 相反取1】  
3，**亦或的操作即：保留原来hashcode值得高16位，新得hashcode值得低16位实际上是由原来得高16位与低16位进行亦或得到的，即：可以将高低位二进制特征混合起来（我觉得这个词说的很好）**  
<**为什么要进行亦或操作而不是其他**>
 **异或运算能更好的保留各部分的特征，如果采用&运算计算出来的值会向0靠拢，采用|运算计算出来的值会向1靠拢**

然后，获得的新的hash值会进行：
```
(p = tab[i = (n - 1) & hash])
```
操作获取对应的数组的槽位；

从这个问题也能看出来，**为什么hashMap的数组长度为2的n次幂**

**1、为了让哈希后的结果更加均匀**  
**2、可以通过位运算e.hash & (newCap - 1)来计算，a % (2^n) 等价于 a & (2^n - 1)  ，位运算的运算效率高于算术运算，原因是算术运算还是会被转化为位运算**


《**这是表面原因，%len和&(len-1)效率问题其实差距不大，&也就是%的4倍左右的差距；2n的核心原因是hash函数的源码中右移了16位让低位保留高位信息，原本的低位信息不要，那么进行&操作另一个数低位必须全是1，否则没有意义，所以len必须是2n，也就是要尽量把数据分配均匀！**》【讲道理这个解释不错】

**终目的还是为了让哈希后的结果更均匀的分部，减少哈希碰撞，提升hashmap的运行效率**

#### 数据库

#### 高性能包（concurrent，锁）

#### 网络

#### Redis

#### Kafka

#### Dubbo

#### Zookeeper

#### Netty

#### Elasticsearch

#### Spring

#### Spring Boot

#### Spring Cloud

#### 微服务架构

#### 场景设计题目

#### 线上问题排查





